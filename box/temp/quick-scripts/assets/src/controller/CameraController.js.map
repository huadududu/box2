{"version":3,"sources":["CameraController.js"],"names":["cc","Class","extends","Component","properties","target","default","type","Node","camera","Camera","onLoad","startFollow","canvas","find","getComponent","Canvas","visibleSize","view","getVisibleSize","initZoomRatio","zoomRatio","centerAtStart","node","position","convertToWorldSpaceAR","Vec2","ZERO","previousPos","pointerPan","overview","speedZoom","on","onMouseMove","onTouchMove","pointerPos","jumpZoom","onEnable","director","getPhysicsManager","attachDebugDrawToCamera","onDisable","detachDebugDrawFromCamera","SetCameraMidPos","posy","midX","x","midY","midPoint","p","parent","convertToNodeSpaceAR","getOverviewTargetsMidpoint","minX","minY","maxX","maxY","i","overviewTargets","length","y","overviewMargin","distX","Math","abs","distY","ratio","max","width","height","shakeCamera","canShake","scheduleOnce","stopShake","bind","shakeDuration","anim","stop","event","getLocation"],"mappings":"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","file":"CameraController.js","sourceRoot":"..\\..\\..\\..\\..\\assets\\src\\controller","sourcesContent":["cc.Class({\r\n    extends: cc.Component,\r\n\r\n    properties: {\r\n        target: {\r\n            default: null,\r\n            type: cc.Node\r\n        },\r\n        camera: cc.Camera\r\n    },\r\n\r\n    // use this for initialization\r\n    onLoad: function () {\r\n        this.startFollow = false;\r\n        let canvas = cc.find('Canvas').getComponent(cc.Canvas);\r\n        this.visibleSize = cc.view.getVisibleSize();\r\n        this.initZoomRatio = this.camera.zoomRatio;\r\n        //place camera on target if centerAtStart\r\n        if (this.centerAtStart) {\r\n            this.node.position = this.target.convertToWorldSpaceAR(cc.Vec2.ZERO);\r\n        }\r\n        this.previousPos = this.node.position;\r\n        if (this.pointerPan) {\r\n            // this.jumpZoom = false;\r\n            this.overview = false;\r\n            this.speedZoom = false;\r\n            canvas.node.on('mousemove', this.onMouseMove, this);\r\n            canvas.node.on('touchmove', this.onTouchMove, this);\r\n            this.pointerPos = null;\r\n        }\r\n        if (this.overview) {\r\n            this.jumpZoom = false;\r\n            this.speedZoom = false;\r\n        }\r\n        if (this.speedZoom) {\r\n            this.jumpZoom = false;\r\n        }\r\n    },\r\n\r\n    onEnable: function () {\r\n        cc.director.getPhysicsManager().attachDebugDrawToCamera(this.camera);\r\n    },\r\n    onDisable: function () {\r\n        cc.director.getPhysicsManager().detachDebugDrawFromCamera(this.camera);\r\n    },\r\n\r\n    // called every frame, uncomment this function to activate update callback\r\n    /*lateUpdate: function (dt) {\r\n        let targetPos;\r\n\r\n        if (this.overview){\r\n            targetPos = this.target.parent.convertToWorldSpaceAR(this.getOverviewTargetsMidpoint());\r\n        } else {\r\n            targetPos = this.target.parent.convertToWorldSpaceAR(this.target.position);\r\n        }\r\n\r\n        if (this.pointerPan && this.pointerPos) {\r\n            let xDelta = this.pointerPos.x / (this.visibleSize.width/2) - 1;\r\n            let yDelta = this.pointerPos.y / (this.visibleSize.height/2) - 1;\r\n            xDelta *= this.pointerXMult;\r\n            yDelta *= this.pointerYMult;\r\n            targetPos = cc.pAdd(targetPos, cc.p(xDelta, yDelta));\r\n        }\r\n\r\n        //smooth follow\r\n        if (this.smoothFollow) {\r\n            if (Math.abs(targetPos.x - this.node.x) >= this.followX ||\r\n                Math.abs(targetPos.y - this.node.y) >= this.followY) {//when camera and target distance is larger than max distance\r\n                this.startFollow = true;\r\n            }\r\n            if (this.startFollow) {\r\n                this.node.position = this.node.position.lerp(targetPos,this.followRatio);\r\n                if (cc.pDistance(targetPos, this.node.position) <= this.minFollowDist) {\r\n                    this.startFollow = false;\r\n                }\r\n            }\r\n        } else {\r\n            this.node.position = this.node.parent.convertToNodeSpaceAR(targetPos);\r\n        }\r\n\r\n        //speed zoom\r\n        if (this.speedZoom) {\r\n            let curSpeed = Math.abs(this.previousPos.x - targetPos.x) / dt;\r\n            let ratio = 0;\r\n            if (curSpeed > this.zoomOutSpeed) {\r\n                ratio = 1 - (curSpeed - this.zoomOutSpeed) / (this.zoomInSpeed  - this.zoomOutSpeed);\r\n                this.camera.zoomRatio = cc.lerp(this.camera.zoomRatio, ratio, 0.02);\r\n            } else {\r\n                this.camera.zoomRatio = cc.lerp(this.camera.zoomRatio, this.initZoomRatio, 0.02);\r\n            }\r\n        }\r\n\r\n        this.previousPos = targetPos;\r\n\r\n        //jump zoom\r\n        if (this.jumpZoom) {\r\n            let ratio = targetPos.y / cc.winSize.height;\r\n            this.camera.zoomRatio = 1 + (0.6 - ratio) * 0.35;\r\n        }\r\n\r\n        //boundaries\r\n\r\n        if (this.useBoundaries) {\r\n            let width = (this.visibleSize.width/2) / this.camera.zoomRatio;\r\n            let height = (this.visibleSize.height/2) / this.camera.zoomRatio;\r\n            let minX = this.node.x - width;\r\n            let maxX = this.node.x + width;\r\n            let minY = this.node.y - height;\r\n            let maxY = this.node.y + height;\r\n            if (minX < this.leftBound) {\r\n                this.node.x = this.leftBound + width;\r\n            }\r\n            if (minY < this.bottomBound) {\r\n                this.node.y = this.bottomBound + height;\r\n            }\r\n            if (maxX > this.rightBound) {\r\n                this.node.x = this.rightBound - width;\r\n            }\r\n            if (maxY > this.topBound) {\r\n                this.node.y = this.topBound - height;\r\n            }\r\n        }\r\n    },*/\r\n    SetCameraMidPos:function(posy){\r\n        let midX=this.target.position.x;\r\n        let midY=posy;\r\n        let midPoint=cc.p(midX,midY);\r\n        this.node.position = this.node.parent.convertToNodeSpaceAR(midPoint);\r\n        this.previousPos = midPoint;\r\n\r\n\r\n    },\r\n\r\n    getOverviewTargetsMidpoint () {\r\n        let midPoint = cc.p(0, 0);\r\n        let minX = 99999, minY = 99999, maxX = -99999, maxY = -99999;\r\n        for (let i = 0; i < this.overviewTargets.length; ++i) {\r\n            let target = this.overviewTargets[i];\r\n            maxX = target.x > maxX ? target.x : maxX;\r\n            minX = target.x < minX ? target.x : minX;\r\n            maxY = target.y > maxY ? target.y : maxY;\r\n            minY = target.y < minY ? target.y : minY;\r\n        }\r\n        maxX += this.overviewMargin;\r\n        minX -= this.overviewMargin;\r\n        maxY += this.overviewMargin;\r\n        minY -= this.overviewMargin;\r\n        let distX = Math.abs(maxX - minX);\r\n        let distY = Math.abs(maxY - minY);\r\n        midPoint = cc.p(minX + distX/2, minY + distY/2);\r\n        let ratio = Math.max(distX / this.visibleSize.width, distY / this.visibleSize.height);\r\n        this.camera.zoomRatio = 1/ratio;\r\n        return midPoint;\r\n    },\r\n\r\n    shakeCamera () {\r\n        if (!this.canShake) return;\r\n        // this.anim.play('shake');\r\n        this.scheduleOnce(this.stopShake.bind(this), this.shakeDuration);\r\n    },\r\n\r\n    stopShake () {\r\n        this.anim.stop();\r\n        this.camera.node.position = cc.p(0, 0);\r\n    },\r\n\r\n    onMouseMove (event) {\r\n        this.pointerPos = event.getLocation();\r\n    },\r\n\r\n    onTouchMove (event) {\r\n        this.pointerPos = event.getLocation();\r\n    }\r\n});"]}